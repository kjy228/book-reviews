# 실용주의 프로그래머

## 0. 서문

역자는 이 책을 개발자를 위한 탈무드요, 수신서라고 생각한다. 힘이 딸리고 어려울 때 읽으면 재충전이 되고 새롭게 다짐을 하게 되는 그런 책이 있다. 이 책이 바로 그런 책이다.

- 무엇이 실용주의 프로그래머를 만드는가?

`🌱자신의 기술에 관심과 애정을 가져라.`
`🌱자신의 일에 대해 생각하면서 일하라!`

***
## 1. 실용주의 철학

### 1. 고양이가 내 소스코드를 삼켰어요

🔗가장 큰 약점은 약점을 보일 것에 대한 두려움이다. _보쉬에

`🌱어설픈 변명을 만들지 말고 대안을 제시하라.`
부탁하는 것을 어려워하지 말고, 도움이 필요하다는 사실을 인정하라.

### 2. 소프트웨어 엔트로피

`🌱깨진 창문을 내버려두지 말라.`
깨진 창문이란 나쁜 설계, 잘못된 결정 혹은 형편없는 코드를 말한다. 깨진 창문을 고치지 않은채로 내버려 두지 마라. 발견하자마자 바로 고쳐라. 적절히 고칠 시간이 충분치 않다면 판자로 덮는 것만이라도 하라. 깨진 창문 두세개를 고른 다음 동료들과 함께 무엇이 문제고, 그걸 고치기 위해 뭘 할 수 있는지 토론하라.

### 3. 돌멩이 수프와 삶은 개구리

`🌱변화의 촉매가 되라.`
돌멩이를 내놔야 할 때다. 큰 무리 없이 요구할 수 있을 만한 것을 찾아내라. 그리고 그걸 잘 개발해라.
그게 그다지 중요하지 않은 것처럼 가장하라. 물러나 앉아 기다려라. 계속되는 성공에 합류하기란 쉽다.

`🌱큰 그림을 기억하라.`
개구리는 단지 변화를 감지하지 못하는 것이다. 그런 개구리처럼 되지 마라. 큰 그림에 늘 주의를 기울여라. 개인적으로 무엇을 하고 있는가에만 정신을 쏟지 말고, 주변에서 무슨 일이 벌어지는지 지속적으로 살펴보라.

### 4. 적당히 괜찮은 소프트웨어

`🌱품질을 요구사항으로 만들어라.`
타협과정에 사용자를 참여시켜라. 오늘의 훌륭한 소프트웨어는 많은 경우, 내일의 완벽한 소프트웨어보다 낫다. 사용자들에게 뭔가 직접 만져볼 수 있는 것을 일찍 준다면, 피드백을 통해 종국에는 더 나은 솔루션에 도달할 수 있을 것이다.

- 언제 멈춰야 할지 알라  
완벽하게 훌륭한 프로그램을 과도하게 장식하거나 지나칠 정도로 다듬느라 망치지 말라. 그냥 넘어가고 코드가 현재 상태에서 한동안은 그대로 있도록 놓아두라. 완벽하지 않을 수도 있다.
걱정하지 마라. 완벽해지기란 불가능하다.

### 5. 지식 포트폴리오

🔗지식에 대한 투자가 언제나 최고의 이윤을 낸다. _벤자민 프랭클린

새로운 기술, 언어, 환경이 개발됨에 따라 지식은 옛것이 된다. 불행히도 그것들은 소진하는 자산이다. 웹-년이 흘러가는 속도를 볼때, 이런 것들은 꽤 빨리 일어날 수 있다. 즉, 우리는 지식 포트폴리오에 주기적으로 투자해야 한다.

`🌱지식 포트폴리오에 주기적으로 투자하라.`
-   매년 새로운 언어를 최소 하나는 배워라.  
    다른 언어는 동일한 문제를 다르게 푼다. 몇 개의 서로 다른 접근법을 알면 사고를 확장할 수 있다.  
    더 많은 기술에 익숙하다면, 변화에 더 잘 적응할 수 있을 것이다.
-   기술 서적을 분기마다 한 권씩 읽어라.
-   수업을 들어라.  
    여러분의 기술 달걀을 한 바구니에 모두 담지 마라.
-   비 기술 서적도 읽어라.  
    컴퓨터를 사용하는 것은 사람. 우리는 바로 이 사람들을 만족시키려고 노력하고 있다.  
    방정식에서 인간이라는 변을 잊지 말자.
-   지역 사용자 모임에 참여하라.
-   다른 환경에서 실험해보라.
-   인터넷을 이용하라.  
    고립은 경력에 치명적일 수 있다. 적극적으로 참여해라.
-   요즘 흐름을 놓치지 마라.  
    새롭게 떠오르는 기술이 인기를 끌기 전에 미리 알고 학습하는 것은 저평가된 주식을 찾아내는 것만큼이나 어려울 수 있지만, 이익 또한 그만큼 클 수 있다.

`🌱읽고 듣는 것을 비판적으로 분석하라.`
이런 학습의 기회를 통해 사고를 확장하고 새로운 가능성과 새로운 방법들로 자신을 활짝 개방하게 될 것이다. 만약 스스로 답을 찾지 못하겠다면 누가 답을 찾아줄 수 있을지 그 사람을 찾아라.

### 6. 소통하라!

🔗나는 무시당하느니 차라리 샅샅이 훑어보는 시선이 낫다고 봐요. _메이 웨스트

뭘 가졌는냐 만이 아니라 그걸 어떻게 포장하느냐도 중요하다. 개발자로서 우리는 여러 층과 소통해야 한다.

`🌱무엇을 말하는가와 어떻게 말하는가 모두 중요하다.`
무엇을 말할지 미리 계획하라. 개요를 작성하라. 그리고 자문하라. "이게 내가 말하고자 하는 것을 잘 전달하는가?" 그렇게 될 때까지 다듬어라. 가능하다면 문서 초고에 독자가 참여하도록 하라. 피드백을 받고, 그들의 머릿속을 도용하라. 
질문을 해서 사람들이 이야기를 하도록 북돋우거나, 여러분이 한 말을 그들이 요약하도록 하라.

***
## 2. 실용주의 접근법

중복의 해악과 직교성은 긴밀한 관계가 있다. 전자는 시스템을 통틀어 어떤 지식을 중복하지 말라고 경고하며, 후자는 하나의 지식을 여러 개의 시스템 컴포넌트에 걸쳐 쪼개 놓지 말라고 조언한다.

### 7. 중복과 해악

프로그래머들은 늘 유지보수 모드에 있다. 우리가 이해하고 있는 것은 날마다 바뀐다. 설계를 하거나 코딩을 하는 중에 새로운 요구사항이 도착한다. 어쩌면 환경이 변할 수도 있다. 이유가 무엇이건 간에, 유지보수는 별개의 활동이 아니며, 전체 개발 과정의 일상적인 부분이다.

- 어떻게 중복이 생기는가?

	-   강요된 중복 : 우리는 코드에 왜 주석이 필요한가에 대해 배우지 않는다. 나쁜 코드야말로 많은 주석을 필요로 한다. 또한 마감일이 다가오기 시작하고, 중요한 클라이언트가 계속해서 요구를 하는 긴박한 시기일 경우 문서의 갱신을 뒤로 미루기 쉽다.
	-   부주의한 중복
	-   참을성 없는 중복 : 이미 작성했던 것과 비슷한 루틴이 필요한가? 원래의 것을 복사하고 약간만 바꾸도록 유혹받을 것이다. 만약 이런 유혹을 느낀다면 '돌아가는 길이 지름길이다' 라는 진부한 격언을 기억하라.
	-   개발자간의 중복

`🌱DRY - 반복하지 마라. Don't Repeat Youreself.`  
모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을만한 표현 양식을 가져야 한다.  
헤더 파일에는 인터페이스에 대한 사항을 기록하고, 구현 파일에는 그 코드의 사용자가 알 필요가 없는 상세한 것들을 기록하라.

`🌱재사용하기 쉽게 만들라.`
의례히 비공식적으로 혹은 코드 리뷰시 다른 사람의 소스코드와 문서를 읽도록 하라.

### 8. 직교성

프로그래밍에서 직교성이란 일종의 독립성이나, 결합도 줄이기를 의미한다. 하나가 바뀌어도 나머지에 어떤 영향을 주지 않으면 서로 직교한다고 할 수 있다. 잘 설계된 시스템에서는 데이터베이스 코드가 사용자 인터페이스에 대해 직교할 것이다.

`🌱관련 없는 것들 간에 서로 영향이 없도록 하라.`
시스템은 협력하는 모듈들의 집합으로 구성되어야 하고, 각 모듈은 다른 부분과 독립적인 기능을 구현해야 한다. '특정 기능에 대한 요구사항을 극적으로 변경했을 경우, 몇 개의 모듈이 영향을 받는가?'  
직교적인 시스템에서는 답이 '하나' 여야 한다.

- 직교적으로 살아남기

	-   코드의 결합도를 줄여라. :  부끄럼타는 코드를 작성하라. 불필요한 어떤 것도 다른 모듈에 보여주지 않으며, 다른 모듈의 구현에 의존하지 않는 코드를 작성하라.
	-   전역 데이터를 피하라. : 싱글톤을 사용할 때 불필요한 링크를 유도하지 않는 지 주의를 기울여라.
	-   유사한 함수를 피하라.
	-   버그를 수정하고 테스트를 마친 뒤 버그 수정에 대한 태그를 붙여라.

### 9. 가역성
🔗당신이 가진 생각이 딱 하나밖에 없다면, 그것만큼 위험한 것은 없다. _에밀 사르티에

- 가역성

`🌱최종 결정이란 없다.`
우리가 프로젝트 초기에 항상 최선의 결정을 내리는 것은 아니다. 
결정이 돌에 새겨지는 것이라 가정하고, 발생할지도 모를 우연한 사건들에 대해 준비하지 않는 데에서 실수가 나온다. 결정이 돌에 새겨진 것이 아니라 해변가의 모래 위에 쓰인 글씨라 생각해 보자. 언제든지 큰 파도가 글씨를 지워버릴 수 있다.

- 유연한 아키텍처
많은 사람들이 코들르 유연하게 유지하려고 노력하지만 아키텍처, 배포, 통합 영역의 유연성에 대해서도 관심을 기울일 필요가 있다. 만약 벤더 의존적인 코드를 깨끗하게 분리하지 않으면 어떻게 될까? 벤더 의존적인 수행문들이 코드 전반에 흩어져 있을 것이고, 이는 유지보수성, 유연성을 극도로 떨어뜨리게 된다.

### 10. 예광탄
새로운 프로젝트에서도 어둠 속에서 목표물을 맞추어야 한다.

- 어둠 속에서 빛을 내는 코드
`🌱목표물을 찾기 위해 예광탄을 써라.`

예광탄 코드는 나중에 버리려고 만드는 것이 아니다. 계속 사용할 코드로 상용 코드와 마찬가지로 모든 에러 검사, 구조화, 문서화, 자기 검사가 포함된다. 예광탄 개발 방법은 프로젝트는 결코 끝나지 않는다는 관념과도 일맥상통한다.

- 예광탄 코드 접근 방법
	- 사용자들은 뭔가 작동하는 것을 일찍부터 보게 된다.
	- 개발자들이 들어가서 일할 수 있는 구조를 얻는다.
	- 통합 작업을 수행할 기반이 생긴다.
	- 보여줄 것이 생긴다.
	- 진전 상황에 대해 더 정확하게 감을 잡을 수 있다.

예광탄은 지금 맞추고 있는 것이 무엇인지 보여준다. 그러나 그곳이 꼭 목표물이라는 보장이 없다. 그럴 경우 목표물이 맞을 때까지 조준을 옮겨야 한다. 이것이 핵심이다. 

### 11. 프로토타입과 포스트잇

소프트웨어 프토토타입은 위험 요소를 분석하고 노출시켜 이를 매우 저렴한 비용으로 바로잡을 기회를 얻을 수 있다.
프토로타입을 반드시 코드로 작성해야할 필요는 없으며 작업흐름과 애플리케이션 로직과 같은 동적인 것들을 프로토타이핑 해 볼 수 있는 도구이다. 프로토타입은 제한된 몇 가지 질문에 답할 목적으로 설계되기 때문에 실제 제품보다 훨씬 적은 비용으로 빠르게 개발할 수 있다. 하지만 만약 세부사항을 포기할 수 없는 환경에 처해있다면, 앞서 말한 예광탄 스타일이 적절할 수 있다.

`🌱프로토타입을 통해 학습하라.`
프로토타이핑은 학습 경험이며, 프로토타입의 가치는 생성된 코드에 있는 것이 아니라 이를 통해 배우게 되는 교훈에 있다.

- 아키텍처 프로토타이핑
코드를 작성하지 않고 화이트보드, 포스트잇, 인덱스카드 등을 사용해도 좋다. 전체적으로 시스템이 어떻게 동작할지에 대한 감을 잡는 것이 중요하다. 우리는 각 모듈이 실행 중에 필요로 하는 데이터에 접근할 수 있는 경로를 갖고 있는가? 모듈은 데이터를 필요로 할 때 데이터에 접근할 수 있는가?

- 어떻게 프로토타임을 사용하지 않을 것인가?
프로토타입을 코드로 만들 때는 시작하기 전 항상  모두에게 폐기처분할 코드를 만들고 있음을 이해시켜야 한다. 프로토타입을 적절히 사용하면 개발주기 초기에 많은 시간과 돈, 고통과 고생을 줄일 수 있다.

### 12. 도메인 언어
🔗언어의 한계가 곧 자기 세계의 한계다. _루트비히 비트겐슈타인

`🌱문제 도메인에 가깝게 프로그래밍하라.`
사용자가 새로운 사항을 요구했을 경우 그들의 도메인에 더 가깝게 일할 수 있는 도구를 스스로에게 제공할 수 있어야 한다.
어떤 애플리케이션 프로그램을 제어하거나 환경설정하기 위한 단순한 언어든, 규칙이나 절차를 명시하기 위한 더 복잡한 언어든, 문제 도메인에 가까운 곳으로 옮길 방법을 궁리해야 한다. 애플리케이션 사용자의 종류는 다양하며 이들 모두에게 각자의 문제 도메인이 있기 때문에, 각각 소형 환경과 소형 언어를 만들어 줄 수도 있다.

### 13. 추정
추정에 대한 지식을 학습한 경험을 통해 추정 능력을 계발하고, 어디에 크기에 대한 직관적 느낌을 적용해야 할지를 알게 된다면, 무언가의 가능성을 가늠할 수 있는 능력을 발휘할 수 있다.

`🌱추정을 통해 놀람을 피하라.`
얼마나 정확한 것이 충분히 정확한 것인가?

- 어떤 의미에서 모든 답은 추정치이다. 단지 누가 남보다 더 정확한지가 다를 뿐이다.
- 추정은 사용하는 단위가 결과의 해석에 차이를 가져올 수 있다.

그렇다면 추정치는 어디에서 오는가?
- 무엇을 묻고 있는지를 이해하자
- 시스템의 모델을 만들어보라
- 모델을 컴포넌트로 나누어라
- 각 매개 변수에 값을 주어라
- 답을 계산하라
- 추정치를 기록하는 용기

프로젝트 일정을 정할 수 있는 유일한 방법은 진행하는 프로젝트를 경험하는 것뿐이다.
프로젝트 일정을 추정해보자.
- 요구사항 체크
- 위험 분석
- 설계, 구현, 통합
- 사용자와 함께 검증

`🌱코드와 함께 일정도 반복하며 조정하라.`
누군가 추정에 대해 물으면 무엇이라 대답해야 할까?
질문에 바로 대답하지 말고, 잠시 시간을 내어 앞서 기술한 단계들을 순서대로 밟아나간다면 가장 정확한 일정 추정치를 알려줄 수 있다.

***
## 3. 기본적인 도구
도구는 재능을 증폭한다. 도구가 더 훌륭하고, 그걸 어떻게 사용하는지 더 잘 알 수록, 더 생산적일 수 있다.
많은 신입 프로그래머들은 특정 통합 개발 환경같은 도구 하나만을 고집하는 실수를 저지르는데, 이는 정말 실수이다.
우리는 IDE가 강제하는 편리함의 울타리 바깥에서도 능숙하게 작업할 수 있어야 한다.

### 14. 일반 텍스트의 힘
일반 텍스트란 사람이 직접 읽고 이해할 수 있는 형태의 인쇄가능한 문자로 이루어진 텍스트이다.
일반 텍스트를 사용하면 그걸 생성하는 어플리케이션에 상관없이 어떤 의미인지 자명한 데이터 흐름을 얻을 수 있다.
`🌱지식을 일반 텍스트로 저장하라.`

하지만 일반 텍스트를 사용하는데는 여러 단점이 있다. 압축된 이진 포맷을 사용하는 것보다 더 많은 공간을 차지하며 일반 텍스트 파일을 해석하고 처리하는데 있어 더 많은 계산이 필요할 수 있다.

### 15. 조개 놀이
모든 작업을 GUI로만 한다면, 여러분이 가진 환경의 전체 능력을 이용하지 못하게 된다. 일반적인 작업을 자동화할 수 없고, 쓸 수 있는 도구의 풀파워를 사용할 수 없다. GUI의 장점은 WYSIWYG (What You See Is What You Get), 즉 여러분이 보는 것이 여러분이 얻는 것이라면 단점은 WYSIAYG (What You See If All You Get), 여러분이 보는 것이 여러분이 얻는 전부이다.

`🌱명령어 셸의 힘을 사용하라.`
셀에 익숙해지면 생산성이 급상승하는것을 알게 될 것이다.

### 16. 파워 에디팅
`🌱하나의 에디터를 잘 사용하라.`
하나의 에디터를 골라 완전히 마스터하고, 모든 편집 작업에 그 에디터를 사용하라. 또한 선택한 에디터가 사용하는 모든 플랫폼에서 가능한지 확인하라.

|만약 자신이 이렇다면...|이걸 고려해 보라..|
|-|-|
|나는 여러 개의 에디터에서 기본적인 기능만 사용한다.|강력한 에디터 하나를 골라 그걸 제대로 익혀라.|
|선호하는 에디터가 있긴 한데, 그 기능을 모두 사용하진 않는다.|모든 기능을 사용해보고 입력해야 하는 키 개수를 줄여라.|
|선호하는 에디터가 있고 가능하다면 그걸 사용한다.|이미 하는 작업 외에 좀 더 많은 작업에 확장하여 사용하라.|

여러분이 그 에디터를 사용하면 행복하고, 또 생산적이라면 그걸 사용해라. 하지만 스스로가 '에디터 선망'에 걸릴 수 있다는 생각이 들면 스스로의 위치를 재평가할 필요가 있을 것이다.

### 17. 소스코드 관리
🔗진보라는 것은 변화와는 거리가 멀고 오히려 기억에 의존한다. 과거를 기억하지 못하는 사람은 과거를 반복할 운명이다. _조지 산타야나, 이성의 삶

소스코드 관리 시스템 혹은 좀 더 넓은 의미의 형상 관리 시스템은 소스코드나 문서 관련의 모든 변화를 기억한다.

`🌱언제나 소스코드 관리 시스템을 사용하라.`
언제나, 혼자서 한 주짜리 프로젝트를 진행하는 경우일지라도, 나중에 '버리기로 한' 프로토타입일지라도, 심지어 여러분이 작업하는 것이 소스코드가 아닐지러라도. 모든 것이 소스코드 관리 아래 있도록 하라.
전체 프로젝트를 소스코드 관리 시스템의 아래에 두는 것은 제품 빌드가 자동화되고 그것을 반복할 수 있다는 이점이 있다.

### 18. 디버깅
`🌱비난 대신 문제를 해결하라.`
디버깅은 단지 문제 해결이라는 사실을 포용하고, 그 방식으로 공략하라.
버그가 우리의 잘못인지 다른 사람의 잘못인지는 중요한 게 아니다. 그 버그는 우리의 문제로 남는다.

🔗가장 속이기 쉬운 사람은 자기 자신이다. _에드워드 불워-리톤

`🌱디버깅을 할 때 당황하지 마라.`
디버깅을 할 때 근시를 조심하라. 표면에 보이는 증상만 고치려는 욕구에 저항하라.
실제 문제는 여러분이 관찰하고 있는 것에서 몇 단계 떨어져 있고, 또 다른 여러 가지와 연관되어 있을 확률이 다분하다.
항상 문제의 근본적인 원인을 발견하려고 노력하고, 그 문제의 특정한 증상만 고치려고 하지 말라.

- 디버깅 전략
	- 버그 재현
	버그를 고치는 최선의 첫 단계는 그 버그를 재현할 수 있게 만드는 것이다. 만약 재현할 수 없다면 어떻게 그 버그를 고쳤다는 것을 알 수 있겠는가?
	
	- 데이터를 가시화하라
	종종 프로그램이 뭘 하는지, 혹은 뭘 할 것인지 알아내는 가장 쉬운 방법은 그 프로그램이 다루는 데이터를 잘 살펴보는 것이다.
	
	- 트레이싱
	트레이싱 구문은 '여기까지 도달' 등 화면에 출력하는 작은 진단용 메시지이다. 디버거가 진단할 수 없는 몇 가지 종류의 에러를 진단하는 데에는 특별히 효과적이다. 
	
	- 고무 오리
	누군가에게 그걸 설명하는 단순한 방법은 문제의 원인을 찾는데 매우 유용하다. 누군가에게 문제를 설명하게 되면 혼자 코드를 살펴볼 때는 당연히 여기고 지나갈 것을 명시적으로 이야기해야 하며 이런 가정들 덕에 문제에 대한 새로운 통찰을 얻을 수 있다.

	- 제거 과정
	라이브러리 혹은 툴 자체에 버그가 있을 수도 있다. 하지만 우리가 개발하고 있는 애플리케이션 코드에 버그가 존재할 가능성이 훨씬 더 크다.
	`🌱'select'는 망가지지 않았다.` 문제가 발생한 지점은 코드의 서로멀리 떨어진 두 군데 중 어느 쪽에서 증상이 나타나는지 본다. 만약 가운데에서 문제가 드러난다면 버그는 시작과 중간 지점의 사이에 존재하며 그렇지 않을 경우 중간과 끝 사이에 존재한다.

	- 놀람의 요소
	`🌱가정하지 마라. 증명하라.`
	놀라운 버그를 마주치면, 단순히 그걸 고치는 것을 넘어 왜 이 실패가 더 일찍 발견되지 않았을까 생각해라. 이 버그를 고치는 데 긴 시간이 걸린다면 왜 그런지 자문하라. 만약 버그가 누군가가 내린 잘못된 가정의 결과라면, 이 문제를 전체 팀과 함께 토론하라.

### 19. 텍스트 처리
`🌱텍스트 처리 언어를 하나 익혀라.`
- 텍스트 처리 언어의 적용범위
	- 데이터베이스 스키마 관리
	- 자바 속성 액세스
	- 테스트 데이터 생성
	- 서적 집필
	- C에서 오브젝트 파스칼 인터페이스로
	- 웹 문서 생성

### 20. 코드생성기
`🌱코드를 작성하는 코드를 작성하라`
- 수동적 코드 생성기
	결과를 내기 위해 한 번만 실행된다. 타이핑을 줄여주며 기본적으로 몇 개의 입력에서 주어진 출력을 생성하는 매개 변수화된 템플릿이다.
	- 새 소스 파일 생성
	- 프로그래밍 언어간 일회용 변환을 수행하기
	- 런타임에 계산하기엔 비용이 많이 드는 참조 테이블과 여타 자원을 생성하기
- 능동적 코드 생성기
	코드 생성이 필요할 때마다 작동한다. DRY 원칙을 따를 경우 필수적으로 써야 한다.
	- 어떤 지식을 단 하나의 형태로만 만들어놓고 애플리케이션이 필요로 하는 온갖 형식으로 변환할 수 있다. 
	- 이렇게 만들어진 형식들은 언제라도 버릴 수 있고, 필요할 때마다 코드 생성기가 만들어내기 때문에, 이것은 중복이 아니다.
- 코드 생성기가 꼭 복잡할 필요는 없다.
- 코드 생성기가 꼭 코드를 생성해야할 필요는 없다.

***
## 4. 실용주의 편집증
`🌱완벽한 소프트웨어는 만들 수 없다.`
우리는 문제가 생기기 전에 주의를 하고, 일어나지 않을 법한 일을 기대하며, 남의 입장에서 생각해보지 않는다. 조금이라도 의심이 들 경우 주어진 모든 정보를 확인하며. 잘못된 데이터를 찾아내기 위해 단정문을 사용한다.
하지만 실용주의 프로그래머들은 '그들은 자기 자신 역시 믿지 않는다.' 자기 자신도 완벽한 코드를 작성할 수 없음을 알기 때문에 자신의 실수에 대비해 방어적으로 코드를 작성한다.

### 21. 계약에 의한 설계
정직한 거래를 보장하는 최선의 해법 중 하나는 계약이다. 사람들이 서로 소통하는 것을 돕기 위해 격식적으로나 비격식적으로 전 세계에 걸쳐 사용된다.
정확한 프로그램이란 스스로 자신이 하는 일이라고 주장하는 것보다 많거나 적지도 않게 딱 그 만큼만 하는 프로그램을 말한다. 이 주장을 문서화하고 검증하는 것이 계약의 의한 설계(DBC)의 핵심이다.

- 선행조건(precondition)
	루틴이 호출되기 위해 참이어야 하는 것. 즉 루틴의 요구사항.
- 후행조건(postcondition)
	루틴이 자기가 할 것이라고 보장하는 것. 즉 루틴이 완료되었을 때 세상의 상태.
- 클래스 불변식(class invariant)
	호출자의 입장에서 볼 때는 이 조건이 언제나 참이라고 클래스가 보장한다.
	

무슨 일이 벌어지는 간에 계약이 부응하지 못하는 게 버그가 되어버리는 실수를 저지르지 마라.
`🌱계약에 따른 설계를 하라.`
게으른 코드를 작성하라. 시작하기 전에 자신이 수용할 것에 대해서는 엄격하게 하고, 내어줄 것에 대해서는 최소한도를 약속하는 것이다.
- 오류 발생시 소비자의 입장을 우선하라.
	이는 모든 시스템 사용자와 맺는 계약이며, 작동에 대한 우리의 보증이다.

### 22. 죽은 프로그램은 거짓말을 하지 않는다.
모든 에러는 정보를 준다. 우리는 에러가 발생할 리 없다고 스스로를 설득할 것이다.
반면 실용주의 프로그래머는 에러가 있을 경우 정말로 나쁜 일이 생긴 것이라고 자신에게 이야기한다.
`🌱일찍 작동을 멈추게 하라.`
가능한 한 빨리 문제를 발견하게 되면, 좀 더 일찍 시스템을 멈출 수 있다.
불가능한 뭔가가 발생했다는 것을 코드가 발견한다면, 프로그램은 더 이상 유효한다가고 할 수 있다. 이 시점 이후로 하는 일은 모두 수상쩍은게 되며 되도록 빨리 종료해야 한다.

### 23. 단정적 프로그래밍
`🌱단정문을 사용해서 불가능한 상황을 예방하라.`
"하지만 물론 그건 절대 일어나지 않을 거야."라는 생각이 든다면, 그걸 확인하는 코드를 추가하라.
이걸 하는 가장 간단한 방법은 단정문(assertion)을 사용하는 것이다.

- 단정문에 전달된 조건은 부작용이 있으면 안 된다.
- 컴파일 중에 단정 기능이 꺼져 있을 수도 있다는 걸 기억하라.
- 실행되어야만 하는 코드는 절대 assert 속에 두지 마라.
- 진짜 에러처리 대신 단정을 사용하지는 마라. 단정은 결코 일어나면 안되는 것들을 검사한다.

- 단정 기능을 켜두라
	- 단정문에 대한 오해
		단정은 코드에 과부하를 주며 결코 일어날 수 없는 것들을 검사하기 때문에 코드 속 버그에 의해서만 촉발될 것이다. 
		즉, 단정은 디버깅 도구일 뿐이다.
	- 테스트가 모든 버그를 발견할 수 없다.
	- 낙관주의자들은 프로그램이 험한 세상에서 돌아간다는 사실을 잊는다.
	- 퍼포먼스 문제가 있다 할지라도, 정말 문제가 되는 단정문만 끄도록 하자.

### 24. 언제 예외를 사용할까
예외는 의외의 상황을 위해 남겨두어야 한다. 잡히지 않은 예외는 프로그램을 종료시킬 것이라고 가정하고, '모든 예외 처리기를 제거해도 이 코드가 여전히 실행될까.'라고 자문해 보자. 만약 그 답이 '아니오.'라면 아마도 예외가 비예외적인 상황에서 사용되고 있는 것이다.'
`🌱예외는 예외적인 문제에 사용하라.`
예외가 있다는 것은 즉 컨트롤의 이동이 즉각적이고 로컬하지 않다는 것이다. 예외를 정상적인 처리 과정의 일부로 사용하는 프로그램은 고전적인 스파게티 코드의 가독성 문제와 관리성 문제를 전부 떠안게 된다.

### 25. 리소스 사용의 균형
`🌱시작한 것은 끝내라.`
이상적으로  리소스를 할당하는 루틴이나 객체가 리소스를 해제하는 책임 역시 져야한다는 걸 의미한다.
- 중첩 할당
	- 리소스를 할당한 순서의 반대로 해제하라. 한 리소스가 다른 리소스를 참조하는 경우에도 리소스를 고아로 만들지 않는다.
	- 코드의 여러 곳에서 동일한 리소스 집합을 할당하는 경우, 할당 순서를 언제나 같게 하라. 교착(deadlock) 가능성이 줄어들 것이다.
- 객체와 예외
	- 할당과 해제의 균형은 클래스의 생성자와 소멸자를 생각나게 한다. 클래스는 하나의 리소스를 대표하며, 생성자는 그 리소스 타입의 특정 객체를 제공하고, 소멸자는 그것을 현 스코프에서 제거한다.
- 균형과 예외
	- 예외를 지원하는 언어는 리소스 해제에 복잡한 문제가 있을 수 있다. 예외가 던져진 경우, 그 예외 이전에 할당된 모든 것이 깨끗이 청소된다고 어떻게 보장할 수 있겠는가?
	- 자바에서 리소스 사용의 균형
		try 블록에 finally 절이 있다면, 그 절 안의 코드들은 try 블록 안의 코드가 한 문장이라도 실행되면 반드시 실행되도록 되어 있다. finally절 안의 코드는 반드시 실행되므로 리소스 사용의 균형을 잡을 수 있다.
- 리소스 사용의 균형을 잡을 수 없는 경우
	- 보통 동적 자료 구조형을 사용하는 프로그램에서 종종 발생한다.
	- 최상위 구조의 할당을 해제할 경우
		- 최상위 구조 자신이 자기 안에 들어있는 하위 구조들의 할당을 해제할 책임이 있다. 하위 구조들은 또 다시 재귀적으로 자기 안에 들어있는 자료들을 해제할 책임이 있다.
		- 최상위 구조에서 그냥 할당이 해제된다. 그 안에서 참조하던 구조들은 모두 연결이 끊어져 고아가 된다.
		- 최상위 구조는 하나라도 하위 구조를 가지고 있을 경우 자기의 할당 해제를 거부한다.
- 균형을 점검하기
	- 정말로 리소스가 적절하게 해제되었는지 실제로 점검하는 코드를 늘 작성하는 것이 언제나 좋다.


***
## 5. 구부러지거나 부러지거나
되돌릴 수 있는 의사 결정을 내릴 수 있는 구체적인 방법에 대해 설명한다.
'세상 돌아가는 대로 돌아가는' 코드를 작성해보자.

### 26. 결합도 줄이기와 디미터 법칙
코드를 모듈로 구성하고, 이들 간의 상호작용을 제한하라. 그러면 한 모듈이 변경되거나 교체된다 하더라도 다른 모듈들은 변경 없이 수행될 수 있을 것이다.

- 결합도 줄이기
불필요한 의존이 많은 시스템은 유지보수가 어렵고, 이로 인한 비용 발생도 크며 시스템 자체가 매우 불안정한 경향이 있다.
우리는 의존도를 최소화하기 위해 아래 디미터 법칙을 사용하여 메서드와 함수를 설계한다.

- 디미터 법칙
`🌱모듈간의 결합도를 최소화하라.`
디미터 법칙은 프로그램에서 모듈간 결합도를 최소화하려 시도한다. 이 법칙은 한 객체가 제공하는 메서드에 접근하기 위해 또 다른 객체들을 통하는 것을 허용하지 않는다. 객체의 모든 메서드는 다음에 해당하는 메서드만을 호출해야 한다.

```java
class Demeter {
	private: 
        A *a;
        int func();
	public:
		// 생략
		void example(B& b);
	void Demeter::example(B& b) {
		C c;
		int f = func();	// func() : 자신
		b.invert();	// 메서드로 넘어온 인자
		a = new A();
		a->setActive();	// 자신이 생성한 객체
		c.print();	// 직접 포함하고 있는 객체
	}
}
```

​	디미터 법칙을 따르면 함수를 호출하는 클래스의 응답집합 크기를 줄일 수 있기 때문에 좀 더 에러가 적은 클래스들을 만들 수 있다.
​	코드를 더 적응성 있고 강하게 만들어 주지만 모든 하부 계약자를 직접 관리하고, 이들에게 일을 위임해주어야 하는 '주계약자'의 역할 수행이 필요하다.

### 27. 메타프로그래밍
세부사항을 코드에서 몰아내라. 우리의 코드는 매우 설정 가능하게 되고 '소프트' 해진다. 즉 변화에 쉽게 적응할 수 있다는 것이다.

- 동적 설정
`🌱통합하지 말고 설정하라.`
우선 시스템을 되도록 설정가능하게 만들어보자.
메타데이터를 이용하여 반환 매개 변수, 사용자 선호사항, 설치 디렉터리와 같은 애플리케이션 설정 옵션을 기술하라.
- 메타데이터 주도 애플리케이션
가능한 많은 메타데이터를 사용하여 애플리케이션을 설정하고 실행시켜라. 어떻게가 아닌 무엇을 해야 하는지를 명시함으로써 선언적으로 생각하는 것이고, 이로써 더 동적이고 적응가능한 프로그램을 만드는 것이다.
`🌱코드에는 추상화를, 메타데이터에는 세부 내용을`
가능한 마지막 순간까지 세부 정의를 피하고, 세부사항을 소프트하게, 변화하기 쉽게 남겨 두라.




출처 _'실용주의 프로그래머(앤드류 헌트, 데이비드 토머스-인사이트'