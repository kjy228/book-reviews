# Servlet

스프링부트를 사용하여 톰캣서버를 내장화를 통해 서블릿코드 실행

## Annotation 정리
### @ServletComponentScan
[참고]https://www.baeldung.com/spring-servletcomponentscan

@ServletComponentScan은 어느 configuration없이 사용할 수 있는데 그 이유는 내장된 서블렛컨테이너때문이다. 임베디드 컨테이너들은 @WebServlet, @WebFilter, @WebListner 를 지원하지 않기 때문에 내장컨테이너에 의존하는 스프링부트는 세로운 어노테이션인 @ServletComponentScam을 사용한다.
```java
package hello.servlet;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.web.servlet.ServletComponentScan;

@ServletComponentScan // 서블릿 자동 등록
@SpringBootApplication
public class ServletApplication {

	public static void main(String[] args) {
		SpringApplication.run(ServletApplication.class, args);
	}

}
```

메인클래스에 `@ServletComponentScan` 을 사용하면 application.class 하위의 패키지들에서 모두 사용할 수 있다. 

HTTP 요청이 오면 WAS가 request, response 객체를 만들어서 서블렛에게 전달한다.

```java
@WebServlet(name = "helloServlet", urlPatterns = "/hello")
public class HelloServlet extends HttpServlet {

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println("HelloServlet.service");
        System.out.println("request = " + request);
        System.out.println("response = " + response);

        String username = request.getParameter("username");
        System.out.println("username = " + username);

        response.setContentType("text/plane");
        response.setCharacterEncoding("utf-8");
        //아래 코드를 사용하여 response 객체에 값을 대입할 수 있다.
        response.getWriter().write("hello" + username);

    }
}
```

`@WebServlet`을 사용하여 HTTP요청을 통해 매핑된 URL이 호출되면 서블릿 컨테이너는 ` protected void service(HttpServletRequest request, HttpServletResponse response)` 메서드를 자동으로 호출한다. 

## Servlet container 동작 방식

<img width="659" alt="image" src="https://user-images.githubusercontent.com/43670838/209827848-9a6f703f-3e77-41bf-ac95-ef192a685fd4.png">

스프링부트로 생성한 application을 실행하면 내장톰캣버서가 서블릿 컨테이너를 띄워준다. 
그 후, 웹에서 WAS를 통해 request를 보내면 WAS는 자동으로 request, response 객체를 생성해서 url에따라 servlet을 실행하고 response에 value를 세팅하여 웹에게 내려준다. 


## HttpServletRequest
HTTP요청 메시지 파싱을 편리하게 사용할 수 있도록 개발자 대신에 HTTP요청 메시지를 파싱한다. 그 결과를 HttpServletRequest객체에 담아서 제공한다. 

` 임시 저장소 `기능을 제공한다. 
HTTP 메시지요청이 들어와 응답을 보내기까지가 HttpServletRequest객체의 생존기간인데 그동안 request.setAttribute, request.getAttribute를 사용하여 값을 저장 조회 할 수 있다. 



## JSP
servlet만 사용하게 되면 아래 사진과 같은 자바코드에 html을 사용해야 되는 끔찍한 상황이 발생하게된다. 왜 끔찍하냐면 html 태그를 사용하면서 오타가 발생할 확률이 높고 다른 개발자들이 이 코드를 보고 어떤 화면인지 파악하기 힘들기 때문에 가독성도 현저히 떨어지게 된다. 따라서 이런 불편함을 해소하기위해 jsp 를 사용 한다.
![image](https://user-images.githubusercontent.com/43670838/212692640-0c2683f3-9727-4198-95aa-b0ea2308a5d8.png)

```
build.gradle 의존성 주입
implementation 'org.apache.tomcat.embed:tomcat-embed-jasper'
implementation 'jakarta.servlet.jsp.jstl:jakarta.servlet.jsp.jstl-api'
```

###  JSP 문법
```jsp
<!--> html 태그 위에 아래 코드 필수 </-->
<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<!-->java 코드 import </-->
<%@ page import="hello.servlet.domain.member.Member" %>
<%@ page import="hello.servlet.domain.member.MemberRepository" %>

<!-->java 코드 </-->

<%
    //request, response 사용 가능
    MemberRepository memberRepository = MemberRepository.getInstance();

    System.out.println("MemberSaveServlet.service");
    String username = request.getParameter("username");
    int age = Integer.parseInt(request.getParameter("age"));
%>

```
jsp에 java 코드를 작성하면 자동으로 servlet으로 변환되어 HttpServlet의  request, response를 사용할 수 있다.


하지만 jsp도 불완전하다. 코드를 보면 java코드, 데이터를 조회하는 레포지토리 등 다양한 코드가 모두 JSP에 노출되어있따. jsp가 너무 많은 역할을하며 유지보수 측면에서도 한 파일의 크기가 굉장히 커질 수 있따. 이러한 문제를 해결하기 위해서 비즈니스 로직은 서블릿 처럼 다른고셍서 처리하고, JSP 는 목적에 맞게 HTML로 view를 그리는 일에 집중하도록 `MVC` 패턴이 등장했다.

## MVC 패턴
` 변경의 라이프 사이클` UI 일부 수정하는 일과 비스니스 로직을 수정하는 일은 각가 다르게 발생할 가능성이 높고서로 대부분 영향을 주지 안흔다. 이렇게 변경의 라이프 사이클이 다른 부분을 하나의 코드로 관리하는것은 유지보수하기 좋지 않다. 
` 기능 특화` JSP 같은 뷰 템플릿을 화면을 렌더링 하는데 최적화 되어있기 때문에 이 부분의 업무만 담당하는것이 가장 효과적이다.

`Controller` HTTP 요청을 받아서 파라미터를 검증하고 비즈니스 로직 시행. 뷰에 전달할 결과 데이터를 받아서 모델에 답는다. 
`Model`: 뷰에 출력할 데이털르 담아둔다. 뷰가 필요한 데이터를 모두 모델에 담아서 전달해주는 덕분에 뷰는 비즈니스 로직이다. 
`View`: 모델에 담겨있는 데이터를 사용해서 화면을 그리는 일에 집중한다.

```java
@WebServlet(name = "mvcMemberFormServlet", urlPatterns = "/servlet-mvc/members/new-form")
public class MvcMemberFormFServlet extends HttpServlet {
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String viewPath = "/WEB-INF/views/new-form.jsp";
        RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
        dispatcher.forward(request,response);
    }
}
```
`dispatcher.forward()` :  다른 서블릿이나 jsp로 이동할수 있는 기능이며 서버내부에서 재호출이 발생한다. 
`/WEB-INF`: 이 경로안에 JSP가 있으면 외부에서 직접  JSP 호출할 수 없다. 

`redirect vs forward`
리다이렉ㄹ트는 실제 클라이언트에 응다빙 나갓다가, 클라이언트가 redirect경로로 재요청한다. 따라서 클라에서 인지할 수 있고 url 경로도 실제 변ㄱ여된다. 반면 포워드는 서버 내부에서 일어나느 호출이기 때문에 클라가 인지하지 못한다.

## MVC 한계
컨트로러는 중복이 많고 피요하지 않은 코드가 많다. 

`포워드 중복` 
View로 이동하는 코드가 중복호출된다. 메서드로 공통화해도 되지만 해당 메서드도 항상 직접 호출해야한다. 
```java
        RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
        dispatcher.forward(request,response);
```

`viewPath 중복`
```java
    String viewPath = "/WEB-INF/views/members.jsp";
```
viewPath 에서 jsp가 아니라 thymeleaf같은 다른 뷰로 변경한다면 전체 코드를 다 변경해야한다. 

기능이 복잡해 질수록 컨트롤러에서 공통으로 처리햐아 하는 부분이 점점 더 많이 증가할 것이다. 단순히 공통 기능을 메서드로 뽑으면 될 것 같지만, 결과적으로 해당 메서드를 항상 호출해야 하고 실수로 호출하지 않으면 문제가된다. 또한 호출하는것 자체가 중복이다. 



## Adapter Pattern
- 기존 코드를 재사용하기위해 내적, 외적 구조를 변환하는 작업을 처리하며 인터페이스를 처리하고 인터페이스를 활용해 보정코드를 사용한다. 
기능상 문제 이 동작하는 코드가 단지 인터페이스 차이 때문에 사용할 수 없는 경우 많이 응용되는 패턴이다. 
- 오래된 레거시 코드나 라이브러리ㅡㄹ 재사용할 때 유용한 패턴이다. 서로 호환되지 않는 인터페이스를 가진 코드를 결함하여 응용 프로그램에서 동작할 수 있도록 도와준다.

## DispatcherServlet 살펴보기
스프링 MVC도 프론트컨트롤러 패턴으로 구현되어있따. 
스프링 MVC 컨트롤러가 바로 DispatcherSErvlet이다. 
이 DispatcherServlet이 바로 MVC의 핵심이다. 

스프링 부트는 dispatcherServlet을 서블릿으로 자동으로 등록하면서 모든경로`urlPatters="/"` 에 대해서 매핑한다. 

*요청흐름*
- 서블릿이 호출되먼 `HttpServlet` 이 제공하는 service() 가 호출된다. 
- 스프링 MVC는 dispatcherSErvlet의 부모인 FrameworkServlet에서 service()를 오버라이드 해두었다. 
- service())를 시작으로 `DispatcherServlet.doDispatch() 가 호출된다. 

*동작 순서*
1. 핸들러 조회 : 핸들러 매핑을 통해 요청 URL에 매핑된 핸들러를 조회한다. 
2. 핸들러 어댑터 조회 : 핸들러를 실행할 수 있는 핸들러 어댑터를 조회.
3. 핸들러 어댑터 실행 : 핸들러 어댑터를 실행한다.
4. 핸들러 실행 : 핸들러 어댑터가 실제 핸들러를 실행한다. 
5. Model And View 반환 : 핸들러 어댑터는 핸들러가 반환하는 정보를 ModelandView로 변환해서 반환한다. 
6. viewResolver 호출 : 뷰리졸버를 찾고 실행한다. 
- jsp는 `InternalResourceViewReslover` 가 자동 등록되고 사용된다. 
7. View 반환 : 뷰리졸버는 뷰의 논리이름을 물리 이름으로 바꾸고 렌더링 역할을 담당하는 뷰 객체를 반환한다. 
8. 뷰 렌덜링 : 뷰를 통해서 뷰를 렌더링 한다.
![image](https://user-images.githubusercontent.com/43670838/221402899-67df3345-5cbc-4263-b17f-723d5644dca8.png)


## @Controller 이전의 spring Controller


```java
package hello.servlet.web.springmvc.old;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

@Component("/springmvc/old-controller")
public class OldController implements Controller {
    @Override
    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
        return null;
    }
}
```
Controller implements할때 `web.springmvc.old` 패키지 아래에있는 controller를 사용해야한다.
그 후 `@Component` 의 bean 이름을 url로 설정해야된다.


### 스프링부트가 자동으로 등록하는 핸들러 매핑과 핸들러 어댑터
**HandlerMapping**
```
0 = RequestMappingHandlerMapping : 어노테이션 기반의 컨드롤러인 @RequestMapping에서 사용
1 = BeanNameUrlHandlerMapping : 스프링 빈의 이름으로 핸들러를 찾는다.
```

**HandelrAdapter**
```
0 = RequestMappingHandlerAdapter : 어노테이션 기반의 컨드롤러인 @RequestMapping에서 사용
1 = HttpRequestHandlerAdapter : HttpRequestHandler 처리
2 = SimpleControllerHandlerAdapter : Controller 인터페이스(어노테이션x, 과거에 사용)처리
```
핸들러 매핑, 핸들러 어뎁터도 모두 순서대로 찾고 만약 없으면 `다음순서` 로 넘어 간다.

springboot의 자동 기능을사용하여 위의 controller가 어떻게 접근되는지 순서로 나타내면
1. 핸들러 매핑으로 핸들러를 조회한다. 이 경우 빈 이름으로 핸들러를 찾아야 하기 땜누에 이름 그대로 빈 이름으로 핸들러를 찾아주는 `BeanNmeUrlHandlerMapping`가 실행에 성공하고 핸들러인 `OldController`를 반환한다. 
2. 핸들러 어댑터 조회 : `HandlerAdapter`의 `supports()` 를 순서대로 호출하여 SimpleCOntrollerHandlerAdapter가 지원 대상이된다. 
3. 핸들러 어댑터 실행
디스패쳐 서블릿이 조회한 SimpleControllerHandlerAdapter를 실행하면서 핸들러 정보도 함꼐 넘겨준다. 


```java
@Component("/springmvc/request-handler")
public class MyHttpRequestHandler implements HttpRequestHandler {
    @Override
    public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println("MyHttpRequestHandler.handlerRequest");
    }
}
```
위의 코드로 application 실행후 localhost:8080/springmvc/request-handler 접속시 spring내부에서 어떻게 찾을까?

`핸들러 매핑으로 핸들러 조회`
1. HandlerMapping을 순차적으로 실행해서 핸들러를 찾는다. 
2. 이 경우 빈 이름으로 핸들러를 찾아야 하기 때문에 이름 그대로 빈 이름으로 핸들러를 찾아주는 `BeanNameUrlHandlerMapping` 가 실행에 성공하고 핸들러인 `MyHttpRequestHandler` 를 반환한다. 
`핸들러 어댑터 조회`
1. `HandlerAdapter`의 `supports()를 순서대로 호출한다. 
2. `HttpRequestHandlerAdapter`가 `HttpRequestHandler 인터페이스를 지원하므로 대상이 된다. 

`핸들러 어댑터 실행`
1.디스패쳐 서블릿이 조회한 `HttpRequesthandlerAdapter를 실행하면서 핸들러 정보도 함께 넘겨준다. 
2.`HttpRequestHandlerAdapter는 핸들러인 `MyHttpRequestHandler`를 내부에서 실행하고 그결과를 반환한다.


## ViewResolver

```java
@Component("/springmvc/old-controller")
public class OldController implements Controller {
    @Override
    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
        System.out.println("OldController.handlerRequest");

        return new ModelAndView("new-form");
    }
}
```

```
//appication.properties
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp
```
prefix와 suffix를 등록하면  ModelAndView에서 jsp를 리턴할 수 있다. 그 이유는 스프링 부트에서 아래코드를 자동으로 설정해주기 때문이다.
```java
@Bean
ViewResolver internalResourceViewResolver(){
    return enw InternalResourceViewResolver("/WEB-INF/views/", ".jsp");
}
```

# SpringMVC

`@Contorller`
- 스프링이 자동으로 빈으로 등록한다.(내부에 `@Component가 있어서 컴포넌트 스캔의 대상이 됨)
- 스프링MVC에서 어노테이션 기반 컨트롤러로 인식한다.
- `ReuqestMappingHandlerMapping` 은 스프링 빈 중에서 `@RequestMapping`, `@Controller 가 클래스 레벨에 붙어있는 경우 매핑정보로 인식한다.
